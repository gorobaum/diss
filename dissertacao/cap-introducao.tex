%% ------------------------------------------------------------------------- %%
\chapter{Introdução}
\label{cap:introducao}

  O alinhamento espacial ou geométrico entre duas imagens - a imagem
\textbf{Referência} e a \textbf{Alvo} - da mesma cena é um problema clássico de
visão computacional, chamado de \textbf{Registro de Imagens}. O registro é uma
função de transformação que leva uma das imagens para o espaço geométrico da
outra, atenuando deformações presentes nas imagens. O registro parte de uma
correspondência entre pontos de interesse das duas imagens, criando um
mapeamento pixel a pixel entre as imagens. As deformações corrigidas pelo
registro são introduzidas por várias condições, como aquisições em horários
diferentes, utilização de sensores diferentes ou mudanças na posição do sensor.

  O registro é aplicado em imagens médicas com várias finalidades, como por
exemplo: (i) na junção de informações de imagens de diferentes modalidades,
como a sobreposição de imagens de ressonância magnética com imagens de raio-x;
(ii) estudos envolvendo atlas anatómicos, onde cada paciente do estudo tem seus
dados registrados para um modelo de estudo; (iii) corrigir diferenças de
imagens de pré- e pós-operatório, causadas por movimentações do paciente e por
movimentação de tecido mole, como a movimentação do pulmão na respiração.

  Os algoritmos de registro são categorizados baseando-se na natureza da
transformação usada para alinhar as imagens. Os \textbf{Algoritmos de Registro
Rígido} definem o primeiro grupo, onde estão os algoritmos que usam
transformações rigidas, usadas para corrigir deformações simples. Esses
algoritmos modelam a função de registro com uma combinação de rotações,
translações, mudanças de escala ou cisalhamentos. Esse tipo de modelagem não
é sulficiente para corrigir movimentações fisiológicas mais complexas, como
as resultantes do batimento do coração ou do movimento respiratório. Para tal,
os \textbf{Algoritmos de Registro Não-Rígido} são utilizados nesse caso. Esses
algoritmos utilizam transformações não lineares para modelar a deformaçãyo
presente nas imagens. O fluxo óptico ou a utilização de equações de dinâmica de
fluidos para aproximar a transformação são exemplos de soluções para casos
não-rigidos. O estudo se foca nos registros não-rigidos.

  Um dos algoritmos mais utilizados pela comunidade cientifica para resolver
casos de registro não-rigidos é o \textbf{Thin Plate Splies} (TPS). O TPS
utiliza uma função de transformação radial, onde cada ponto de controle exerce
uma influencia, atenuada pela distancia entre eles, sobre todos os outros
pontos de controle. O TPS modela a deformação presente nas imagens como uma
deformação aplicada a uma chapa fina de metal, onde os pontos de controle
escolhidos nas imagens funcionam como pesos, modelando a chapa no espaço.
O TPS é capaz de registrar deformações complexas, mas seu tempo de execução
é fortemente influenciado pelo número de pontos de controle empregados no
registro \cite{zitova2003image}.

  Logo o TPS se beneficia de algum tipo de aceleração. O principal objetivo do
trabalho é apresentar uma implementação do TPS para o modelo \textit{Single
Instruction, Multiple Data} \cite{patterson2013computer}, modelo esse adotado
pelas Unidades de Processamento Gráfico (GPU). A escolha de GPUs para a
aceleração do TPS vem do crescimento na simplicidade da utilização delas para
tarefas que não estão ligadas a processamento gráfico, e o baixo custo do
processamento por dolar do seu hardware. Neste trabalho, a implementação do TPS
para o paradigma Programação Genérica em Unidades de Processamento Gráfico
(GPGPU) é chamanda de mapeamento para GPU. Os resultados apresentados por
\cite{membarth2011frameworks} levaram a escolha do CUDA como a linguagem
utilizada neste trabalho.
%% ------------------------------------------------------------------------- %%
\section{Trabalhos Relacionados}
\label{sec:trabalhosRelacionados}

  O TPS foi introduzido como um método de registro por
\cite{bookstein1989principal}. O autor realiza um extenso estudo sobre a
influência da escolha e do espaçamento entre pontos de controle no resultado do
TPS, e valida a utiliza do TPS como algoritmo de registro aplicando-o no estudo
da Sindrome de Apert, onde pacientes apresentam deformações nos ossos faciais
\ref{fig:apert}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{figuras/apert.png}
    \source{\cite{bookstein1989principal}}
    \caption{Entrada do TPS no registro da Sindrome de Apert. Na imagem a
             esquerda estão os pontos de controle em uma criança normal. Na
             imagem a direita os pontos de controle em uma criança portadora de
             Apert.}
    \label{fig:apert}
\end{figure}

  A implementação do TPS descrita por \textit{Bookstein} utiliza a mesma
função de transformação apresentada por \cite{goshtasby1988registration}, onde
cada ponto de controle é interpolado na exata possição de outro ponto na
imagem alvo. \cite{rohr1996nonrigid} introduz um fator de suavização à função
de transformação do TPS, com a justificativa que essa suavização permite um
melhor resultado quando os pontos de controle não são bem relacionados e uma
exata interpolação é impossivel. Em uma continuação do seu trabalho,
\cite{rohr2001landmark} acresenta uma modelagem para pontos de controles que
foram mal definidos, adicionando uma aproximação quadrática quando a posição
de algum ponto de controle é usado. Para melhorar o tempo de execução do TPS,
\cite{flusser1992adaptive} propõe a aplicação do TPS em subregiões quadradas ou
triangulares das imagens, diminuindo o número de pontos de controle e cada uma
das instâncias do TPS. \cite{beatson1992fast} aplica expansões hierárquicas na
função de transformação do TPS para reduzir o tempo de execução final. Esse
método cálcula explicitamente a influência de pontos de controles próximos,
enquanto simplifica a interação de pontos de controles distantes. Com isso,
o tempo de execução da influência de um ponto de controle sobre os outros cai de
$\mathcal{O}(n_{cp}^2)$ para $\mathcal{O}(n_{cp}\log{n_{cp}})$.

\subsection{GPGPU e Registro}

  A utilização de GPUs para agilizar o processo de registro é algo comum
atualmente, principalmente pela facilidade e mapear problemas de visão
computacional para GPUs. \cite{strzodka2004image} foi um dos primeiros artigos
a portar um algoritmo de registro não-rigido para GPUs. Nele, um método discreto
de minimização de fluxo de gradiente foi implementado em GPGPU, utilizado o
\textbf{DirectX 9} para a implementação. \cite{kohn2006gpu} expandiu o trabalho
anterior, criando uma versão do algoritmo para imagens em três dimensões,
realizando uma etapa de registro rígido antes do não-rígido. \cite{vetter2007non}
realiza o mapeamento de um algoritmo de registro multimodal para imagens médicas.
Esse trabalho é um dos primeiros a explicar como os recursos da GPU foram
utlizados no mapemento, como por exemplo a organização dos dados na memória.
O trabalho de \cite{grossauer2008gpu} relata a criação de um algoritmo para
registro que utiliza fluxo óptico em conjunto com métodos de \textit{Multi Grid},
usados para resolver equações diferenciais parciais. Ele descreve a aceleração
do \textit{Multi Grid}, dada a sua afinidade com o \textit{Pipeline} gráfico.

  Em \cite{bui2009performance} o registro rigido de imagens multimodais médicas
utilizando flúxo optico. A implementação foi realizada em CUDA
\cite{nvidia2007compute}. \cite{han2009gpu} utiliza Informação Mutua para
realizar um registro não-rígido de imagens cerebrais de ressonância magnética
e 17 atlas médicos, com a finalidade de segmentar regiões de interesse nos
pacientes.Em 2010, o artigo de \cite{modat2010fast} define um algoritmo de
registro não-rígido chamado de \textit{Free-Form Deformation}, desenvolvido
para registrar imagens de ressonância magnética T1. Diferente de outros
algoritmos, ele foi desenvolvido para executar em GPUs diretamente. Para tal,
os autores utilizam uma interpolação B-Spline cúbica e uma modificação da
informação mutua como métrica para o registro. Ele separa cara passo em vários
\textit{kernels} diferentes, fazendo com que cada \textit{kernel} utilize o
máximo de memória possível e então espalha o processamento para um maior número
de processadores na GPU, melhorando o desempenho do algoritmo. Para comparar o
resultado, uma implementação em C++ foi feita. O estudo de
\cite{membarth2011frameworks} realiza uma comparação entre vários arcabouços de
programação para GPU, entre eles o CUDA e o OpenCL utilizando como caso de
comparação o registro de imagens 2D/3D, ou seja, o registro de imagens em três
dimensões de tomografia computadorizada para imagens de raio-X. O artigo então
segue primeiro com uma comparação conceitual entre os vários arcabouços e
depois com uma comparação de desempenho. Foram feitas comparações com a
execução sequencial, em paralelo e em GPU do algoritmo.

\begin{center}
  \begin{tabular}{| l | l | l | p{6em} |}
  \hline
  Artigo & Hardware (Implementação) & Tamanho da Imagem & Tempo de Execução (Speedup) \\ \hline
  \cite{strzodka2004image} & GeForceFX 5800 (DX9) & $513 \times 769$ & 8.3s (4x) \\ \hline
  \cite{kohn2006gpu} & GeForce 6800 (DX9) & $256 \times 256 \times 128$ & 5s (12x) \\ \hline
  \cite{vetter2007non} & GeForce 7800 GTX (DX10) & $512 \times 512$ & 3.9s (6x) \\ \hline
  \cite{bui2009performance} & Tesla C870 (CUDA) & $512 \times 512$ & 0.69s (7.48x) \\ \hline
  \cite{han2009gpu} & GeForce GTX 280 (CUDA) & $256 \times 256 \times 128$ & 19s (25x) \\ \hline
  \cite{modat2010fast} & GeForce 8800 GTX (CUDA) & $181 \times 217 \times 181$ & 42s (9.89x) \\ \hline
  \cite{luo2014gpu} & Tesla C2050 (CUDA) & $256 \times 256 \times 94$ & 0.252s (69x) \\ \hline
  \end{tabular}
\end{center}

  Pouco avanço foi feito na melhoria do desempenho do TPS utilizando GPU. A
grande parte dos trabalhos emprega um mapeamento trivial, sem entrar em detalhes
sobre a implementação nem evidenciar a utilização de recursos da GPU para tentar
melhorar o mapemanto. Tanto \cite{richa2011towards} quanto
\cite{schoob2013stereoscopic} apresentam algoritmos usados por cameras no
auxilio em operações cardiovasculares. Para operar em tempo real, requisito
minimo para esse tipo de sistema, os dois trabalhos utilizam implementações
em GPUs NVIDIA do TPS, mas sem entrar em detalhes sobre o mapeamento feito.
\cite{luo2014gpu} apresenta um mapeamento completo do TPS utilizando CUDA,
explicando como cada etapa do algoritmo é implementado. O trabalho, porém, não
desfruta de nenhum método para melhorar o desempenho de aplicações em CUDA,
como mapeamento de imagens para texturas ou cálculo ativo de ocupação de
recursos.

%% ------------------------------------------------------------------------- %%
\section{Objetivos}

  Vários trabalhos na última década estudam o mapeamento de algoritmos de
registro para GPUs. Normalmente, só o mapeamento dos métodos é apresentado, sem
explorar recursos encontrados nas placas gráficas que podem ser aplicados para
aumentar o desempenho da implementação. Dentre tais recursos estão a utilização
a execução concorrente de vários kernels ou a utilização de texturas
tridimensionais.

  O principal objetivo do trabalho é apresentar uma implementação do Thin Plate
Splines em GPU, aperfeiçoado para a execução de $n$ instâncias de registro, onde
cada instância registra uma imagem alvo diferente para a mesma imagem referência.
Nossa implementação será separada em blocos, que podem ser executados tanto em
CPU quanto em GPU, a escolha do usuário. Os objetivos específicos deste
trabalho são:

\begin{enumerate}
  \item Desenvolver uma implementação configurável, que possa ser executada
  em ambientes GPU ou CPU
	\item Identificar quais melhorias de desempenho características da GPU podem
        ser aplicadas no mapeamento do TPS
  \item Estudo comparativo entre as melhorias aplicadas
  \item Explorar soluções para incrementar o desempenho na execução do registro
  de várias imagens alvo para a mesma imagem referência
\end{enumerate}

%% ------------------------------------------------------------------------- %%
\section{Organização do Trabalho}
\label{sec:organizacao_trabalho}

No Capítulo~\ref{cap:conceitos}, os conceitos utilizados pelo trabalho
são apresentados, como registro e GPGPU. O capítulo \ref{cap:metodologia}
mostra como os conceitos são combinados para a criação da implementação que
satisfaz nossos objetivos. No Capítulo \ref{cap:resultados} os experimentos são
descritos e os seus resultados avaliados. Finalmente, no Capítulo
~\ref{cap:conclusoes} analisamos os resultados obtidos.

%% ------------------------------------------------------------------------- %%
\chapter{Introdução}
\label{cap:introducao}
	O alinhamento de imagens entre duas ou mais imagens é um problema clássico dentro de visão computacional. O alinhamento
leva pontos de uma imagem para pontos de outra imagem, criando uma função de correspondência entre elas. Alguns exemplos
do que esse alinhamento é capaz: podemos criar imagens a partir de imagens menores, chamado de Costura 
(\textit{Stitching ou Mosaicking}); realizar a junção de imagens diferentes da mesma cena em uma única imagem, chamado 
de Fusão (\textit{Image Fusion}); é possível retirar deformações de uma imagem dada uma imagem base, como é feito no
processamento de imagens médicas, onde o alinhamento de uma imagem nova de um paciente com uma antiga é capaz de
retirar possíveis diferenças entre elas. Existem ainda várias outras aplicações para o alinhamento de imagens.

	Chamamos o processo de alinhamento de imagens de Registro. os algoritmos de registro podem ser em dois grupos, 
baseando-se na natureza da transformação que é usada para alinhar as imagens. O primeiro grupo, o registro rígido, 
alinha as imagens utilizando transformações afins, ou seja, ele é capaz de aplicar operações simples ao alinhar imagens,
como rotações, translações e mudanças de escala. Isso não é o suficiente para resolver a maioria dos problemas de registro.
Em um dos exemplos dados acima, o registro é capaz de retirar diferenças entre imagens médicas. As diferenças mais 
encontradas são causadas por movimentações do tecido mole, criando deformações não uniformes, que não podem ser representadas
por transformações afins. Para realizar o registro desses casos, o segundo grupo de algoritmos é usado, o registro não-rígido, que utiliza várias transformações complexas para realizar o alinhamento das imagens. Fluxo óptico ou aproximação
para fluidos são exemplos de instancias para essas transformações.

	O registro é altamente custoso computacionalmente, por dois motivos. O primeiro é o número de etapas que devem ser
realizadas antes do algoritmo de registro em si. Dependendo da qualidade das imagens ou do algoritmo usado, todas as 
imagens devem passar por um pré-processamento. Depois, características são encontradas em cada imagem, e correspondências
são feitas entre características de imagens diferentes. Com tudo isso feito, o algoritmo de registro é executado para
encontrar, dentro do espaço de parâmetros da transformação escolhida, o melhor conjunto que quando aplicado a transformação
nos de o alinhamento das imagens. A transformação escolhida depende da área de aplicação, logo não podemos escolher uma 
transformação que seja computacionalmente rápida se ela não irá nos dar os resultados esperados.

	Outro motivo para o grande tempo de execução do registro é a crescente quantidade de dados. Um exemplo dessa crescente
quantidade de dados são as imagens \textit{Gigapixel}, imagens compostas por milhões de pixels. Elas são criadas para 
representar com a maior quantidade de detalhes possíveis imagens de cidades, do espaço e até de micro estruturas, em 
estudos biológicos. Em 2010 o projeto criado por \cite{sevilla111}, que mantinha o recorde mundial com uma imagem de 111 
\textit{Gigapixels}, foi composto usando 9,750 imagens. Em apenas dois anos o projeto de \cite{london320} criou uma foto
esférica de Londres com 320 \textit{Gigapixels}, criada a partir de 48,640 imagens. Todas as outras áreas em processamento
de imagens são capazes do mesmo feito, dada a facilidade na transmissão e manutenção de dados, estudos que antigamente
usavam centenas de imagens podem facilmente utilizar milhares.

	Logo o registro tem que sofrer algum tipo de aceleração. Nossa abordagem nesse trabalho é traduzir o registro para o 
ambiente de Programação Genérica em Unidades de Processamento Gráfico (GPGPU). A motivação para utilizar as Unidades de 
Processamento Gráfico (GPU) como hardware para a execução do processo de registro vem da velocidade com que a sua 
capacidade de processamento aumenta, atrelado ao baixo custo por poder de processamento dessas placas. Ao escolher o 
algoritmo de registro que será utilizado temos que tomar o cuidado para que ele se adapte ao paradigma de programação em 
GPU a ponto de ganhar um aumento de velocidade considerável e que ainda sim seja capaz de registrar uma gama grande de 
imagens.

%% ------------------------------------------------------------------------- %%
\section{Trabalhos Relacionados}
\label{sec:objetivo}
	Desde que as Unidades de Processamento Gráfico começaram a ser usadas em meados dos anos 2002 para execução de 
código genérico, ou seja, sem a finalidade de renderizar uma cena, vários trabalhos traduziram algoritmos para a GPU.
Algoritmos esses que são aplicados em várias áreas, como cálculo numérico, simulações cientificas e processamento de 
imagens.

	Uma das primeira aplicações envolvendo o uso de GPUs no processamento de imagens foi feito por 
\cite{fung2005openvidia}, que descreve o arcabouço de programação \textit{OpenVIDIA}, criado a partir do 
\textit{OpenGL}, desenvolvido por \cite{opengl}. Antes do \textit{OpenVIDIA} o processamento de imagens em GPUs era
feito utilizando o \textit{OpenGL}, uma linguagem para processamento gráfico, voltada para a renderização de cenas. Os
algoritmos para processamento de imagem eram reescritos para utilizarem primitivas do \textit{OpenGL}. O 
\textit{OpenVIDIA} criou um encapsulamento de chamadas do \textit{OpenGL} voltado para imagens, retirando a necessidade
de traduzir os algoritmos e facilitando a utilização dos \textit{shaders} programáveis da GPU.

	Com a introdução de linguagens próprias para programação em GPU, vários algoritmos de processamento de imagens foram
traduzidos para a execução em GPUs. Na área de registro um dos primeiros artigos a tratar do assunto foi 
\cite{strzodka2004image}, que apresenta uma implementação de um algoritmo de registro não-rígido que utiliza uma técnica
de redução de energia da diferença das imagens. \cite{kohn2006gpu} expandiu o trabalho anterior, criando uma versão do 
algoritmo para imagens em três dimensões e realizando um registro rígido antes do não-rígido. Ainda programando 
diretamente em \textit{OpenGL}, \cite{vetter2007non} propõem um algoritmo de registro multimodal para imagens médicas 
executando em uma GPU 7800 da \textit{NVIDIA}. O artigo leva em conta a organização da imagem na memória da GPU e o 
tempo de transmissão dos dados da CPU para a GPU.

	O trabalho de \cite{grossauer2008gpu} relata a criação de um algoritmo para registro que utiliza fluxo óptico em 
conjunto com métodos de \textit{Multi Grid}, usados para resolver equações diferenciais parciais. Ele descreve
a aceleração do \textit{Multi Grid}, dada a sua afinidade com o \textit{Pipeline} gráfico. Em \cite{bui2009performance}
o passo de interpolação de um algoritmo de registro multi modal entre imagens médicas é traduzido utilizando uma 
linguagem para programação genérica em GPUs, o CUDA \cite{nvidia2007compute}. O estudo realiza uma comparação de 
eficiência entre o código em CPU e GPU de uma interpolação bilinear, apresentando como resultado uma aceleração de 60 
vezes da GPU em relação a CPU. O algoritmo de registro proposto por \cite{han2009gpu} utiliza Informação Mutua para
realizar um registro não-rígido entre imagens de ressonância magnética entre cérebros de indivíduos e um atlas com a 
finalidade de segmentar regiões de interesse no individuo. O estudo utiliza uma GPU \textit{NVIDIA} em conjunto com a 
linguagem CUDA para registrar as imagens, apresentando uma aceleração de 25 vezes em relação a CPU. Esse estudo, 
juntamente com o anterior, se preocupa com a organização dos dados na memória da GPU, algo que era de dificil controle 
antes do surgimento de linguagens voltadas para GPGPU.

	Em 2010, o artigo de \cite{modat2010fast} define um algoritmo de registro não-rígido chamado de \textit{Free-Form 
Deformation}, desenvolvido para registrar imagens T1 de ressonância. Diferente de outros algoritmos, ele foi desenvolvido
para executar em GPUs diretamente. Para tal, os autores utilizam uma interpolação B-Spline cúbica e uma modificação da
informação mutua como métrica para o registro. Ele separa cara passo em vários \textit{kerneis} diferentes, fazendo
com que cada \textit{kernel} utilize o máximo de memória possível e então espalhando o processamento para um maior número
de processadores na GPU, melhorando o desempenho do algoritmo. 

	O estudo de \cite{membarth2011frameworks} realiza uma comparação entre vários arcabouços de programação para GPU,
entre eles o CUDA e o OpenCL utilizando como caso de comparação o registro de imagens 2D/3D, ou seja, o registro de
imagens em três dimensões de tomografia computadorizada para imagens de raio-X. O artigo então segue primeiro com uma
comparação conceitual entre os vários arcabouços e depois com uma comparação de desempenho. Foram feitas comparações 
com a execução sequencial, em paralelo e em GPU do algoritmo. 
	
%% ------------------------------------------------------------------------- %%
\section{Motivações}
	Vários trabalhos na última década levaram o registro para o mundo GPGPU. Alguns deles implementaram um pedaço do 
algoritmo em GPU, enquanto outros traduziram todo o algoritmo. Porém o registro é composto de vários passos auxiliares
feitos antes do algoritmo principal, como etapas de pré-processamento, descoberta de características e correspondência
das mesmas. Falaremos mais sobre isso no Capitulo \ref{cap:conceitos}. E ainda, a tradução deles é feita pensando em 
uma única execução da etapa de registro, não pensando em execuções continuas, com várias entradas diferentes, onde 
podemos aproveitar a transferência de dados de uma etapa para a outra.
	
	Nossa motivação nesse trabalho é, então, suprir essa lacuna, criando um algoritmo de registro não-rígido em GPU que
cuide de todas as etapas no registro de várias imagens.
%% ------------------------------------------------------------------------- %%
\section{Objetivos}
	O primeiro objetivo do trabalho é identificar, entre os algoritmos mais utilizados para registrar imagens com 
deformações não-rígidas, o melhor candidato para ser traduzido no ambiente GPGPU. Isso deve levar em conta todos os 
passos de um algoritmo de registro, desde o pré-processamento até a construção da imagem registrada. Nosso algoritmo deve,
ainda, ser capaz de lidar com problemas que necessitem do registro de várias imagens, como um estudo clinico sobre 
populações, onde vários pacientes são registrados para um paciente artificial.

	Logo, nosso algoritmo deve ser capaz de otimizar a utilização dos recursos da GPU, minimizando a transferência de dados
entre a CPU e a GPU enquanto maximiza a utilização dos recursos de processamento da GPU.
%% ------------------------------------------------------------------------- %%
\section{Organização do Trabalho}
\label{sec:organizacao_trabalho}

No Capítulo~\ref{cap:conceitos}, apresentamos o que é Registro, Unidade de Processamento Gráfico, GPGPU e os algoritmos 
de registro escolhidos. No Capítulo \ref{cap:resultados} os testes utilizados e os resultados dos dois algoritmos 
escolhidos são apresentados. Finalmente, no Capítulo~\ref{cap:conclusoes} analisamos os resultados obtidos 
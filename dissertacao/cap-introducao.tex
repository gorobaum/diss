%% ------------------------------------------------------------------------- %%
\chapter{Introdução}
\label{cap:introducao}

% \emph{Thesis are random access. Do NOT feel obliged to read a thesis from beginning to end.}

%% ------------------------------------------------------------------------- %%
\section{Trabalhos Relacionados}
\label{sec:objetivo}
	Desde que as Unidades de Processamento Gráfico começaram a ser usadas em meados dos anos 2002 para execução de 
código genérico, ou seja, sem a finalidade de renderizar uma cena, vários trabalhos traduziram algoritmos para a GPU.
Algoritmos esses que são aplicados em várias áreas, como cálculo númerico, simulações cientificas e processamento de 
imagens.

	Uma das primeira aplicações envolvendo o uso de GPUs no processamento de imagens foi feito por 
\cite{fung2005openvidia}, que descreve o arcabouço de programação \textit{OpenVIDIA}, criado a partir do 
\textit{OpenGL}, desenvolvido por \cite{opengl}. Antes do \textit{OpenVIDIA} o processamento de imagens em GPUs era
feito utilizando o \textit{OpenGL}, uma linguagem para processamento gráfico, voltada para a renderização de cenas. Os
algoritmos para processamento de imagem eram reescritos para utilizarem primitivas do \textit{OpenGL}. O 
\textit{OpenVIDIA} criou um encapsulamento de chamadas do \textit{OpenGL} voltado para imagens, retirando a necessidade
de traduzir os alçgoritmos e facilitando a utilização dos \textit{shaders} programáveis da GPU.

	Com a introdução de linguagens próprias para programação em GPU, vários algoritmos de processamento de imagens foram
traduzidos para a execução em GPUs. Na área de registro um dos primeiros artigos a tratar do assunto foi 
\cite{strzodka2004image}, que apresenta uma implementação de um algoritmo de registro não rigido que utiliza uma técnica
de redução de energia da diferença das imagens. \cite{kohn2006gpu} expandiu o trabalho anterior, criando uma versão do 
algoritmo para imagens em três dimensões e realizando um registro rigido antes do não-rigido. Ainda programando 
diretamente em \textit{OpenGL}, \cite{vetter2007non} propõem um algoritmo de registro multimodal para imagens médicas 
executando em uma GPU 7800 da \textit{NVIDIA}. O artigo leva em conta a organização da imagem na memória da GPU e o 
tempo de transmissão dos dados da CPU para a GPU.

	O trabalho de \cite{grossauer2008gpu} relata a criação de um algoritmo para registro que utiliza fluxo optico em 
conjunto com métodos de \textit{Multi Grid}, usados para resolver equações diferenciais parciais. Ele descreve
a aceleração do \textit{Multi Grid}, dada a sua afinidade com o \textit{Pipeline} gráfico. Em \cite{bui2009performance}
o passo de interpolação de um algoritmo de registro multi modal entre imagens médicas é traduzido utilizando uma 
linguagem para programação genérica em GPUs, o CUDA \cite{nvidia2007compute}. O estudo realiza uma comparação de 
eficiência entre o código em CPU e GPU de uma interpolação bilinear, apresentando como resultado uma aceleração de 60 
vezes da GPU em relação a CPU. O algoritmo de registro porposto por \cite{han2009gpu} utiliza Informação Mutua para
realizar um registro não rigido entre imagens de ressonancia magnetica entre cerebros de individuos e um atlas com a 
finalidade de segmentar regiões de interresse no individuo. O estudo utiliza uma GPU \textit{NVIDIA} em conjunto com a 
linguagem CUDA para registrar as imagens, apresentando uma aceleração de 25 vezes em relação a CPU. Esse estudo, 
juntamente com o anterior, se preocupa com a organização dos dados na memória da GPU, algo que era de dificil controle 
antes do surgimento de linguagens voltadas para GPGPU.

	Em 2010, o artigo de \cite{modat2010fast} define um algoritmo de registro não rigido chamado de \textit{Free-Form 
Deformation}, desenvolvido para registrar imagens T1 de ressonancia. Diferente de outros algoritmos, ele foi desenvolvido
para executar em GPUs diretamente. Para tal, os autores utilizam uma interpolação B-Spline cúbica e uma modificação da
informação mutua como métrica para o registro. Ele separa cara passo em vários \textit{kerneis} diferentes, fazendo
com que cada \textit{kernel} utilize o máximo de memória possível e então espalhando o processamento para um maior número
de processadores na GPU, melhorando o desempenho do algoritmo. 

	O estudo de \cite{membarth2011frameworks} realiza uma comparação entre vários arcabouços de programação para GPU,
entre eles o CUDA e o OpenCL utilizando como caso de comparação o registro de imagens 2D/3D, ou seja, o registro de
imagens em três dimensões de tomografia computadorizada para imagens de raio-X. O artigo então segue primeiro com uma
comparação conceitual entre os vários arcabouços e depois com uma comparação de desempenho. Foram feitas comparações 
com a execução sequêncial, em paralelo e em GPU do algoritmo. 
	
%% ------------------------------------------------------------------------- %%
\section{Motivações}
	Vários trabalhos na última década levaram o registro para o mundo GPGPU. Alguns deles implementaram um pedaço do 
algoritmo em GPU, enquanto outros traduziram todo o algoritmo. Porém o registro é composto de vários passos auxiliares
feitos antes do algoritmo principal, como etapas de pré-processamento, descoberta de características e correspondencia
das mesmas. Falaremos mais sobre isso no Capitulo \ref{cap:conceitos}. E ainda, a tradução deles é feita pensando em 
uma única execução da etapa de registro, não pensando em execuções continuas, com várias entradas diferentes, onde 
podemos aproveitar a transferência de dados de uma etapa para a outra.
	
	Nossa motivação nesse tabalho é, então, suprir essa lacuna, criando um algoritmo de registro não rigido em GPU que
cuide de todas as etapas no registro de várias imagens.
%% ------------------------------------------------------------------------- %%
\section{Objetivos}
	O primeiro objetivo do trabalho é identificar, entre os algoritmos mais utilizados para registrar imagens com 
deformações não rigidas, o melhor candidato para ser traduzido no ambiente GPGPU. Isso deve levar em conta todos os 
passos de um algoritmo de registro, desde o pré-processamento até a construção da imagem registrada. Nosso algoritmo deve,
ainda, ser capaz de lidar com problemas que necessitem do registro de várias imagens, como um estudo clinico sobre 
populações, onde vários pacientes são registrados para um paciente artificial.

	Logo, nosso algoritmo deve ser capaz de otimizar a utilização dos recursos da GPU, minimizando a transferência de dados
entre a CPU e a GPU enquanto maximiza a utilização dos recursos de processamento da GPU.
%% ------------------------------------------------------------------------- %%
\section{Organização do Trabalho}
\label{sec:organizacao_trabalho}

No Capítulo~\ref{cap:conceitos}, apresentamos o que é Registro, Unidade de Processamento Gráfico, GPGPU e os algoritmos 
de registro escolhidos. No Capítulo \ref{cap:resultados} os testes utilizados e os resultados dos dois algoritmos 
escolhidos são apresentados. Finalmente, no Capítulo~\ref{cap:conclusoes} analisamos os resultados obtidos 
%% ------------------------------------------------------------------------- %%
\chapter{Introdução}
\label{cap:introducao}

%% ------------------------------------------------------------------------- %%
\section{Trabalhos Relacionados}
\label{sec:trabalhosRelacionados}

% \subsection{GPGPU}
%    \textit{survey} \cite{owens2007survey}
%
% 	Uma das primeira aplicações envolvendo o uso de GPUs no processamento de imagens foi feito por
% \cite{fung2005openvidia}, que descreve o arcabouço de programação \textit{OpenVIDIA}, criado a partir do
% \textit{OpenGL}, desenvolvido por \cite{opengl}. Antes do \textit{OpenVIDIA} o processamento de imagens em GPUs era
% feito utilizando o \textit{OpenGL}, uma linguagem para processamento gráfico, voltada para a renderização de cenas. Os
% algoritmos para processamento de imagem eram reescritos para utilizarem primitivas do \textit{OpenGL}. O
% \textit{OpenVIDIA} criou um encapsulamento de chamadas do \textit{OpenGL} voltado para imagens, retirando a necessidade
% de traduzir os algoritmos e facilitando a utilização dos \textit{shaders} programáveis da GPU.
%
% 	Com a introdução de linguagens próprias para programação em GPU, vários algoritmos de processamento de imagens foram
% traduzidos para a execução em GPUs. Na área de registro um dos primeiros artigos a tratar do assunto foi
% \cite{strzodka2004image}, que apresenta uma implementação de um algoritmo de registro não-rígido que utiliza uma técnica
% de redução de energia da diferença das imagens. \cite{kohn2006gpu} expandiu o trabalho anterior, criando uma versão do
% algoritmo para imagens em três dimensões e realizando um registro rígido antes do não-rígido. Ainda programando
% diretamente em \textit{OpenGL}, \cite{vetter2007non} propõem um algoritmo de registro multimodal para imagens médicas
% executando em uma GPU 7800 da \textit{NVIDIA}. O artigo leva em conta a organização da imagem na memória da GPU e o
% tempo de transmissão dos dados da CPU para a GPU.
%
% 	O trabalho de \cite{grossauer2008gpu} relata a criação de um algoritmo para registro que utiliza fluxo óptico em
% conjunto com métodos de \textit{Multi Grid}, usados para resolver equações diferenciais parciais. Ele descreve
% a aceleração do \textit{Multi Grid}, dada a sua afinidade com o \textit{Pipeline} gráfico. Em \cite{bui2009performance}
% o passo de interpolação de um algoritmo de registro multi modal entre imagens médicas é traduzido utilizando uma
% linguagem para programação genérica em GPUs, o CUDA \cite{nvidia2007compute}. O estudo realiza uma comparação de
% eficiência entre o código em CPU e GPU de uma interpolação bilinear, apresentando como resultado uma aceleração de 60
% vezes da GPU em relação a CPU. O algoritmo de registro proposto por \cite{han2009gpu} utiliza Informação Mutua para
% realizar um registro não-rígido entre imagens de ressonância magnética entre cérebros de indivíduos e um atlas com a
% finalidade de segmentar regiões de interesse no individuo. O estudo utiliza uma GPU \textit{NVIDIA} em conjunto com a
% linguagem CUDA para registrar as imagens, apresentando uma aceleração de 25 vezes em relação a CPU. Esse estudo,
% juntamente com o anterior, se preocupa com a organização dos dados na memória da GPU, algo que era de dificil controle
% antes do surgimento de linguagens voltadas para GPGPU.
%
% 	Em 2010, o artigo de \cite{modat2010fast} define um algoritmo de registro não-rígido chamado de \textit{Free-Form
% Deformation}, desenvolvido para registrar imagens de ressonância magnética pesadas em T1. Diferente de outros algoritmos,
% ele foi desenvolvido para executar em GPUs diretamente. Para tal, os autores utilizam uma interpolação B-Spline cúbica e
% uma modificação da informação mutua como métrica para o registro. Ele separa cara passo em vários \textit{kernels} diferentes, fazendo
% com que cada \textit{kernel} utilize o máximo de memória possível e então espalha o processamento para um maior número
% de processadores na GPU, melhorando o desempenho do algoritmo.
%
% 	O estudo de \cite{membarth2011frameworks} realiza uma comparação entre vários arcabouços de programação para GPU,
% entre eles o CUDA e o OpenCL utilizando como caso de comparação o registro de imagens 2D/3D, ou seja, o registro de
% imagens em três dimensões de tomografia computadorizada para imagens de raio-X. O artigo então segue primeiro com uma
% comparação conceitual entre os vários arcabouços e depois com uma comparação de desempenho. Foram feitas comparações
% com a execução sequencial, em paralelo e em GPU do algoritmo.

%% ------------------------------------------------------------------------- %%
\section{Objetivos}

  Vários trabalhos na última década estudam o mapeamento de algoritmos de
registro para GPUs. Normalmente, só o mapeamento dos métodos é apresentado, sem
explorar recursos encontrados nas placas gráficas que podem ser aplicados para
aumentar o desempenho da implementação. Dentre tais recursos estão a utilização
a execução concorrente de vários kernels ou a utilização de texturas
tridimensionais.

  O principal objetivo do trabalho é apresentar uma implementação do Thin Plate
Splines em GPU, aperfeiçoado para a execução de $n$ instâncias de registro, onde
cada instância registra uma imagem alvo diferente para a mesma imagem referência.
Nossa implementação será separada em blocos, que podem ser executados tanto em
CPU quanto em GPU, a escolha do usuário. Os objetivos específicos deste
trabalho são:

\begin{enumerate}
	\item Explorar soluções para incrementar o desempenho na execução do registro
        de várias imagens alvo para a mesma imagem referência
	\item Identificar quais melhorias de desempenho características da GPU podem
        ser aplicadas no mapeamento do TPS
	\item Desenvolver uma implementação configurável, que possa ser executada
        em ambientes GPU ou CPU
  \item Estudo comparativo entre as melhorias aplicadas
\end{enumerate}

%% ------------------------------------------------------------------------- %%
\section{Organização do Trabalho}
\label{sec:organizacao_trabalho}

No Capítulo~\ref{cap:conceitos}, os conceitos utilizados pelo trabalho
são apresentados, como registro e GPGPU. O capítulo \ref{cap:metodologia}
mostra como os conceitos são combinados para a criação da implementação que
satisfaz nossos objetivos. No Capítulo \ref{cap:resultados} os experimentos são
descritos e os seus resultados avaliados. Finalmente, no Capítulo
~\ref{cap:conclusoes} analisamos os resultados obtidos.
